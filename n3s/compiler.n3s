@prefix : <http://example.org/ns#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix graph: <http://www.w3.org/2000/10/swap/graph#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .

# Prohibition { action X } = Duty { NOT (action X) }
(_:X _:Y _:G) log:onNegativeSurface {
    _:X 
        a :PolicyTarget .

    () log:onProhibitionSurface _:G .

    (_:New) log:onNegativeSurface {
        () log:onDutySurface {
            () log:onNegativeSurface _:G .
        } .
    } .
} .

# Permission { action X } = NOT { Prohibition action X }
(_:X _:Y _:G) log:onNegativeSurface {
    _:X 
        a :PolicyTarget .

    () log:onPermissionSurface _:G .

    (_:New) log:onNegativeSurface {
        _:X a :PolicyTarget . # Due to a bug in eye this line is needed
        () log:onNegativeSurface {
            () log:onProhibitionSurface _:G .
        } .
    } .
} .

# IF Duty { action X } THEN { Permission action X }
(_:X _:Y _:G) log:onNegativeSurface {
    _:X 
        a :PolicyTarget .

    () log:onDutySurface _:G .
    
    () log:onNegativeSurface {
        () log:onPermissionSurface _:G .
    } .
} .

# IF Duty { action X } AND Duty { action Y } THEN Duty { action X,Y }
(_:X _:G1 _:G2 _:G) log:onNegativeSurface {
    _:X
        a :PolicyTarget .

    () log:onDutySurface _:G1 .
    () log:onDutySurface _:G2 .

    (_:G1 _:G2) graph:union _:G .

    () log:onNegativeSurface {
        () log:onDutySurface _:G .
    } .
}.

# Now try to get rid of double negations in specialized surfaces
## ..there is where deontic logic is different than FOL
## ..we use a straightforward approach for simple not too deeply
## ..nested cases for now
(_:G _:F) log:onNegativeSurface {
    () log:onProhibitionSurface _:G .
    _:G log:equalTo {
        () log:onNegativeSurface {
            () log:onNegativeSurface _:F .
        } .
    } .
    () log:onNegativeSurface {
        () log:onProhibitionSurface _:F .
    } .
} .

(_:G _:F) log:onNegativeSurface {
    () log:onDutySurface _:G .
    _:G log:equalTo {
        () log:onNegativeSurface {
            () log:onNegativeSurface _:F .
        } .
    } .
    () log:onNegativeSurface {
        () log:onDutySurface _:F .
    } .
} .

(_:G _:F) log:onNegativeSurface {
    () log:onPermissionSurface _:G .
    _:G log:equalTo {
        () log:onNegativeSurface {
            () log:onNegativeSurface _:F .
        } .
    } .
    () log:onNegativeSurface {
        () log:onPermissionSurface _:F .
    } .
} .

# Now try to find a contradiction within a specialized surfaces
## ..E.g. Duty( A & NOT(A) )
## ..E.g. Prohibition( A & NOT(A) )
## For Permission we skip this test for now. In any world Duties
## and Prohibition should not be contradictory. But, there could 
## be worlds where permissions are contradictory without haveing
## any consequences. E.g. you have a permission to call and not
## call your mother would be ok. You have a duty to call and not
## call your mother would be a contradiction.
(_:G _:F _:S _:P _:O) log:onNegativeSurface {
    () log:onDutySurface _:G .

    _:G log:includes { 
        () log:onNegativeSurface _:F .
    } .
    _:F log:includes { _:S _:P _:O } .
    _:G log:includes { _:S _:P _:O } .
} .

(_:G _:F _:S _:P _:O) log:onNegativeSurface {
    () log:onProhibitionSurface _:G .

    _:G log:includes { 
        () log:onNegativeSurface _:F .
    } .
    _:F log:includes { _:S _:P _:O } .
    _:G log:includes { _:S _:P _:O } .
} .